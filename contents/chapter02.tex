% !TeX root = ../main.tex

\chapter{CGRA compilation}
補DDG 到 CGRA的圖

CGRAs are focus on and basically can only handle the innermost loop of the nested loop\cite{LLP}. And modulo scheduling is pretty efficient to handle loop-level parallelism problem. So the compilation methods of CGRAs are often based on the modulo scheduling manner especially methods nowadays. To accelerate loops on CGRA, the target loop will be extracted. For each target loop, a DDG(data dependency graph) is generated from IR of the input program. DDG is a directed graph describe the dependency of all operations in the target loop. So the compilation of CGRAs is basically a mapping problem. Compiler will map the DDG(data dependency graph) to CGRA's nodes. 

CGRAs are 2D spacial architectures but 3D if we view time as one dimension when P\&R(place and routing). In early stage, CGRA's compiler will simultaneously consider the spatial and temporal mapping problem. MRRGs(Modulo Routing Resource Graphs) is come out in this era\cite{ARC}. MRRG combines features of the modulo reservation table (MRT) for software pipelining and the routing resource graph used in FPGA P\&R\cite{LLP}. So MRRG is kind of a modulo resource table but need to consider the position's relationship. So it needs to consider modulo time, data placement and data routing in the same time. The searching space consist of space and time, but no one issue an efficient and good enough heuristic way to handle this problem. The mapping method in DRESC\cite[]{DRESC}(one kind of mapping method using MRRG) is basically random(with some pruning and analysis) to determine where and when an operation belongs to. Then check it's a legal mapping or not until find a valid schedule. Because of the difficulty and high complexity of simultaneously mapping time and space. So mapping method nowadays don't integrate time and space together. Basically, decomposed mapping policy is the mainstream of CGRA's compilers. If you have interest in the history and abstract of CGRA compilation techniques. That paper\cite[]{JD} summarized and organized them from different perspectives pretty well and comprehensively. 

That paper classifies the mappings to two kind of patten: Integrated and  Decomposed from temporal and spacial perspectives. In my opinion, a better classification can split spacial mapping to placement and routing. So there are three partitions in the mapping of CGRA: time schedule, which DDG's node should map to which CGRA's PE and how to route data by routing resources if the input DDG is too complex. EPIMap\cite[]{EPIMap}, REGIMap\cite[]{REGIMap}, MEMMap\cite[]{MEMMap}, RAMP\cite[]{RAMP} are methods which decompose time and space, but integrate placement and routing together. All of them are extension of EPIMap’s epimorphism problem. The concept of time-extended CGRA(TEC) is also issued by EPIMap. First, compiler will schedule each operation based on iterative modulo schedule\cite[]{IMS}. Then it converts the CGRA's spatial mapping problem to a Maximum Clique Solver(MCS) problem base on the result of time assignment. In EPIMap or other similar mapping, compiler will generate a compatible graph from modified DFG and TEC of target II. The graph is the cartesian product of DFG's nodes and TEC's PEs, each vertex in the graph represent a mapping pair(PE and operation) and if there is an edge between two vertices means the two mapping pairs are compatible to each other. So find a clique of a given input size is equivalent to CGRAs mapping problem. But MCS is also an NP-hard problem. Even in RAMP which is the best of them, the time complexity of the heuristic it use to find a big enough clique in the paper is $O(n^8)$. And even it's already use an $O(N^8)$ algorithm to find a clique, it still can't make sure compiler would find an big enough clique, so the $O(N^8)$ algorithm will run many times. Sometimes it even needs to reschedule time assignment and modify DDG again. So it is still too complex for compiler to simultaneously handle placement and routing.

Unlike EPIMap which integrate placement and routing together, RobustMap\cite[]{JD} combines data routing with time schedule. There is an major advantage of mapping by this way. Compare to placement and routing, the coupling between time schedule and data routing is way more loose. That means we can separate them to two independent problems to some  extent. So the time complexity of spacial mapping is partially transferred to temporal mapping at the expense of some possible solutions. But even there are better solutions in EPIMap-like mappings. Given to the huge search space, limit compilation time, and the lack of good heuristics, finding better solutions is like looking for a needle in a haystack. 
\section{}
